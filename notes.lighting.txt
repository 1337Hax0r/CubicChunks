
HOW MINECRAFT LIGHTING CURRENTLY WORKS:

NOTE: sea level is set at blockY=63 and lots of code uses that constant
	chunk generation
	entity spawning
	lighting

Chunk generation (server only):
	chunks are generated from chunkY=0 all the way up to the "top"
	top isn't always chunkY=15... it's usually 3,4,5
	
	Column CubicChunkGenerator.provideChunk( int chunkX, int chunkZ )
		Column( World world, Block[] blocks, byte[] meta, int chunkX, int chunkZ )
		copies biome info over to the column
		Column.generateSkylightMap()
	ChunkProvider.populateChunk()
		Chunk.func_150809_p() // populateLighting

Chunk loading on client/server:
	no lighting calculations

Block change (client and server):
	World.setBlock( blockX, blockY, blockZ )
		Column.func_150807_a( chunkX, blockY, chunkZ ) // setBlock
			Block.getLightOpacity()
			Column.updateBlockSkylight( localX, blockY+1, localZ )
			Column.updateBlockSkylight( localX, blockY, localZ )
			Column.getSavedLightValue( sky, localX, blockY, localZ )
			Column.getSavedLightValue( block, localX, blockY, localZ )
			Column.propagateSkylightOcclusion()
				updateSkylightColumns[localX,localZ] = true
				isGapLightingUpdated = true
		World.func_147451_t( blockX, blockY, blockZ ) // updateLights
			World.updateLightByType( Sky, blockX, blockY, blockZ )
			World.updateLightByType( Block, blockX, blockY, blockZ )

on column tick:
	Chunk.recheckGaps()
		Column.getHeightValue( localX, localZ )
		for each block x,z neighbor
			World.getChunkHeightMapMinimum( neighborBlockX, neighborBlockZ )
		Column.checkSkylightNeighborHeight( blockX, blockZ )
		for each block x,z neighbor
			Column.checkSkylightNeighborHeight( neighborBlockX, neighborBlockZ, someBlockY )
				World.worldObj.getHeightValue( neighborBlockX, neighborBlockZ )
				Column.updateSkylightNeighborHeight( neighborBlockX, neighborBlockZ, startBlockY, stopBlockY )
					for blockY in range
						World.updateLightByType( sky, neighborBlockX, blockY, neighborBlockZ )
	Chunk.func_150809_p() // populate lighting
		

Modules:

Chunk.func_150809_p() // populateLighting
	for x,z block column:
		Chunk.func_150811_f() // populateBlockColumnLighting()
	for each column x,z edge:
		Chunk.func_150801_a() // populateEdgeLighting()
			Chunk.func_150811_f() // populateBlockColumnLighting()
			
Chunk.func_150811_f() // populateBlockColumnLighting()
	Chunk.getLightOpacity()
	World.func_147451_t() // updateLights
	World.getBlock().getLightValue()

Column.generateSkylightMap()
	loop over ( localX, localY, localZ )
		Chunk.func_150808_b( localX, blockY, localZ ) // getLightOpacity
		CubicChunk.getStorage().setExtSkylightValue( localX, localY, localZ )
		World.func_147479_m( blockX, blockY, blockZ ) // markForRenderUpdate

Column.updateBlockSkylight( localX, blockY, localZ ) // aka relightBlock
	read Column.heightMap[localX,localZ]
	Column.func_150808_b( localX, y, localZ ) // getLightOpacity
	World.markBlocksDirtyVertical( minBlockX, minBlockZ, startBlockY, stopBlockY )
		for blockY in range
			World.updateLightByType( sky, blockX, blockY, blockZ )
	write Column.heightMap[localX,localZ]
	storage.setExtSkylightValue( localX, localY, localZ )
	World.func_147479_m() // markForRenderUpdate
	read/write Column.heightMapMinimum
	for self and x,z neighbors
		Column.updateSkylightForYBlocks( ..., startBlockY, stopBlockY )
			World.worldObj.updateLightByType( sky, blockX, y, blockZ )

World.updateLightByType( type, blockX, blockY, blockZ )
	World.getSavedLightValue( type, blockX, blockY, blockZ )
	World.computeLightValue( blockX, blockY, blockZ, type )
	// uses World.lightUpdateBlockList[] as a queue for lighting updates
	// only used within the score of a single method invocation
	// processing of the lightUpdateBlockList queue calls these functions
		// pass 1
		World.getSavedLightValue( type, updateX, updateY, updateZ )
		World.setLightValue( type, updateX, updateY, updateZ )
		for each block face neighbor:
			World.getBlock( neighborX, neighborY, neighborZ ).getLightOpacity() // will have to replace this call
			World.getSavedLightValue( type, neighborX, neighborY, neighborZ )
		// pass 2
		World.getSavedLightValue( type, updateX, updateY, updateZ )
		World.computeLightValue( updateX, updateY, updateZ, type )
		World.setLightValue( type, updateX, updateY, updateZ )
		for each block face neighbor:
			World.getSavedLightValue( type, neighborX, neighborY, neighborZ )

World.computeLightValue( blockX, blockY, blockZ, type )
	Chunk.canBlockSeeTheSky( blockX, blockY, blockZ )
	for each block face neighbor:
		World.getSavedLightValue( neighborBlockX, neighborBlockY, neighborBlockZ, type )

What queries we need to answer to have cubic chunks:
	Chunk.canBlockSeeTheSky()
		checks Chunk.heightMap
	Chunk.getBlock().getLightValue() // emitted light
	Chunk.getBlock().getLightOpacity() // ability to block light
	Column.getSavedLightValue( block or sky )
	Column.setLightValue( block or sky )
	Column.getLightOpacity()

	
Chunk.heightMap
	read:
		Chunk.canBlockSeeTheSky()
		Chunk.setBlock()
		Chunk.getHeightValue()
	read/write:
		Chunk.generateHeightMap()
		Chunk.generateSkylightMap()
		Chunk.relightBlock() private, called by Chunk.setBlock()
	conclusion:
		can replace heightMap with our light index

Chunk.heightMapMinimum
	read:
		World.getChunkHeightMapMinimum()
	read/write:
		Chunk.generateHeightMap()
		Chunk.generateSkylightMap()
		Chunk.relightBlock() private, called by Chunk.setBlock()
	conclusion:
		used by World, can't replace

Processes that update lights on blocks
	New segment creation
		calls Chunk.generateSkylightMap()
	New chunk creation
		calls Chunk.func_150809_p() // populateLighting
	Block changes
		calls World.func_147451_t() // relightBlock
		and   Chunk.updateBlockSkylight()
		and   Chunk.propagateSkylightOcclusion()
	World tick
		calls World.enqueueRelightChecks()
		and   World.setActivePlayerChunksAndCheckLight()
				randomly recalculates light around random entities
		